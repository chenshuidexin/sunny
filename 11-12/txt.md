## 正则表达式
>专门操作(检索)字符串的一种规则[更擅长处理模糊范围的字符串]
- 难点：规则====>规律 现象 (需要去总结)
- 易点：没有逻辑，只有记住

- 字面量：/规则或不带引号的查询字符/==>'q'  /q/
- new RegExp(字符串或者变量，修饰符)
>什么时候用//什么时候用new RegExp()
   >- /aa/==> 找到的是字符aa
   >- new RegExp(aa)==>找到的是变量aa，本质是找aa的赋值的字符串 
- \:转义字符   把正则中有特殊含义的字符 转成字符本身(不再有任何特殊的含义)转义符转的是后面\的字符
- \n：换行
- \d:查看0-9中一个数字
- \D:一个非数字
- 量词：+ 至少出现一次，最多不限
- 修饰符： 
     - g：global 全局查找
     - i:ignoreCase 忽略大小写
- 正则身上的方法：
    - /a/.exec(字符串)：查看字符串中是否有正则匹配项。找到这个正则匹配的字符串(首次出现的数字字符串(只出现一次))，并返回到数组中找不到就返回null。
    ```js
    ["1", index: 3, input: "dh819dx1", groups: undefined]
    //"1"：找到的字符
    //index："1"首次出现的位置
    //input：整个字符
    //groups:undefined[基本固定]
    //length：1[找的是'1'这个字符串，基本固定为1]
    ```
    - /a/.text(字符串)：查看字符串是否中有正则规则匹配项，有就返回true，没有就返回false。
- string.match(/正则/修饰符) 字符串的方法
   - >找到正则匹配的字符并且把它们放到数组中(返回值是数组，找不到就返回null) ====  跟exec[正则对象的方法]的类似
```js
let aa='asS34SdsS4fsvf'
console.log(aa.match(/s/gi))
console.log(aa.match(/s/ig))//跟上面一样的效果===>gi顺序不妨碍
```
- string.replace(''或//，'替换字符'或函数):字符串方法
  - >替换(老，新)
  ```js
  //参数的第一个参数就是匹配的字符，如果匹配多次那么就会多次调用。
  //在课件1中
  ````
> replace细节知识点：默认情况下，函数的
- 第一个参数是每次匹配字符
- 第二个参数是匹配字符索引
- 第三个参数是整个字符串
- 第四个参数是undefined
>要是有分组的话()
- 第一个参数是每次匹配的字符
- 第二个参数是第一个分组，以后参数就是相对应的分组，知道分组完成后就正常走索引、整个字符串、undefined
>分组():从左往右数**如果分组的后面有量词，那么分组项为最后一个字符** 
```js
//在课件4
```
- ^:字符串开头
- $:字符串结尾
    -   ===> ^ + $ 整个字符串都要匹配正则规则
- []:字符在正则中是找任意一个字符
   - [123] ==> 找[]中的任意一个字符
   - [xx-yy]===>找xx和yy之间的任意一个字符
   - [0-9]--> \d ASCII编码来写的
   - [a-z] --> 小写英文
   - [A-z] --> 大写英文
   - [A-z]--> 会包括几个符号如*|等
   - [A-Za-z]--> 大小写英文
   ```js
   //在课间4
   ```
- 中文区间范围：/[\u4e00-\u9fa5]/
- {}:代表量词  描述{}前面字符的数量
    - {m}  ==>出现m次
    - {m,} ==>最少m个，最多不限。
    - {m,n}->{2,5}
    - + ->{1,} 最少一次，最多不限
    - ？ -> {0,1}最少没有，最多一次
    - * ->{0,} 最少可以没有，最多不限
    - 排除 ==>[^abc]排除字符a或b或c
```js
   let str = 'a12ca456ca6789ca123456caca1ca78c';
    console.log(str.match(/a[^123]+c/g));//a开头c结尾，中间排除1
```


+ 懒惰：让它往东就不会往西，让它往西就不会往东
+ 贪婪：只要符合某个规则就不停的找，直到找不到为止，返回是数组。