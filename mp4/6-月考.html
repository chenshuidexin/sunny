<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <script>
        // console.log(a);//函数
        // var a = 12;
        // function a() {
        //     console.log(a);
        //     a = 13;
        // }
        // a();//报错
        // console.log(a);
        //*********************************************
        // let res = Number(':200px');
        // if (res === 200) {
        //     alert(200);
        // } else if (res === NaN) {
        //     alert(NaN);
        // } else if (typeof res === 'number') {
        //     alert('number');//'number'
        // } else {
        //     alert('Invalid Number');
        // }
        //********************************************
        // var n = 0;
        // function a() {
        //     var n = 10;//11父级

        //     function b() {
        //         n++;
        //         console.log(n);//11 12
        //     }
        //     b();
        //     return b;
        // }
        // var c = a();
        // c();
        // console.log(n);//0
        //***************************************************
        // var a1 = 4,
        //     a2 = [1, 2];

        // function b(x, y) {
        //     arguments[0] = 10;//a1=10 简单数据类型不会改变
        //     arguments[1].push(3);//[1,2,3]  引用类型会改变
        //     y = [];
        //     console.log(x, y);//10 []
        // }
        // b(a1, a2);
        // console.log(a1, a2);//4  [1,2,3]
        //********************************************************
        // function fn(i) {//10   11 //20  21//30
        //     return function (n) {//20  30 //40//50
        //         console.log(n + (i++));//30  //60//80  41
        //     }
        // }
        // var f = fn(10);
        // f(20);
        // fn(20)(40);
        // fn(30)(50);
        // f(30);
        //*********************************************************
        //函数自执行要自己运行再到自执行函数体内的函数在执行
        //加法(+)级别比乘法(*=)
        // var x = 3,
        //     obj = {
        //         x: 5 
        //     };
        // obj.fn = (function () {  
        //     this.x *= ++x; 
        //     return function (y) { 
        //         // debugger;
        //         this.x *= (++x) + y;
        //         console.log(x); //13 234 
        //     }
        // })();
        // var fn = obj.fn;
        // obj.fn(6);
        // fn(4);
        // console.log(obj.x, x) //13 234
        // ***************************************************************
        //example 1****************************************************
        // let a = {},
        //     b = '0',
        //     c = 0;
        // a[b] = '珠峰';
        // a[c] = '培训';
        // console.log(a[b]);//培训==》a[0]='培训'重新赋值
        //example 2**************************************************
        // let a = {},
        //     b = Symbol('1'),
        //     c = Symbol('1');
        // a[b] = '珠峰';
        // a[c] = '培训';
        // console.log(a[b]);//'珠峰'  Symbol()唯一值
        // //example 3************************************************
        // let a = {},
        //     b = {
        //         n: '1'
        //     },//引用类型
        //     c = {
        //         m: '2'
        //     };
        // a[b] = '珠峰';
        // a[c] = '培训';
        // console.log(a[b]);//'培训' ==>a[object Object]='培训' 重新赋值
        //*************************************************************
        // function Fn() {
        //     this.x = 10;
        //     this.y = 20;
        //     this.getX = function () {
        //         console.log(this.x);
        //     }
        // }
        // Fn.prototype.y = 40;
        // Fn.prototype = {
        //     x: 30,
        //     getY: function () {
        //         this.y += 1;
        //         console.log(this.y);
        //     },
        //     sum: function () {
        //         console.log(this.x + this.y);
        //     }
        // };
        // let f1 = new Fn;
        // let f2 = new Fn;
        // console.log(f1.getX === f2.getX);//false
        // console.log(f1.getY === f2.getY);//true
        // console.log(f1.constructor);//ƒ Object() { [native code] }本地函数
        // f1.getX();//10
        // f2.getY();//21 直接就赋值就好
        // f1.sum()//30
        //************************************************************
        // var F = function () {};
        // Object.prototype.a = function () {
        //     console.log('a()')
        // };
        // Function.prototype.b = function () {
        //     console.log('b()')
        // };
        // var f = new F();
        // f.a();//a()
        // // f.b();//报错
        // F.a();//a()==>构造函数最终指向就是Object。
        // F.b();//b()
        //***********************************************************
        // function A1(name) {
        //     this.name = name;
        // }

        // function A2(name) {
        //     this.name = name || 'Jerry';
        // }

        // function A3(name) {
        //      name && (this.name = name);
        // }
        // A1.prototype.name = 'Tom';
        // A2.prototype.name = 'Tom';
        // A3.prototype.name = 'Tom';
        // alert((new A1().name) + (new A2().name)+ (new A3().name));//undefinedJerryTom
        //**********************************************************************
            // var name = "WINDOW",
            //     obj = {
            //         name: "OBJ",
            //         fn: (function () {
            //             console.log(this.name);//'WINDOW' 
            //             return function () {
            //                 console.log(this.name);//'OBJ'
            //             }
            //         })()
            //     },
            //     fn = () => {
            //         console.log(this.name);//'WINDOW' 'WINDOW'
            //     };
            // fn();
            // obj.fn();
            // fn.call(obj);//改变this的指向。箭头函数的call方法指向上下文
        // **************************************************************************
        // function A() {
        //     alert(1);
        // }

        // function Fn() {
        //     A = function () {//函数调用后会干掉187行重新给A赋值。
        //         alert(2);
        //     };
        //     return this;
        // }
        // Fn.A = A;//->此时赋值为function(){alert(1)}
        // Fn.prototype = {
        //     A: () => {
        //         alert(3);
        //     }
        // };
        // A();//1
        // Fn.A();//1 => A() =>1
        // Fn().A();//2
        // new Fn.A();//1  => new A() =>调用A的函数
        // new Fn().A();//3 Fn原型上找A()
        // new new Fn().A();//报错
        //************************************************************************
    </script>
</body>

</html>