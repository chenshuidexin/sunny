<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <script>
        // ****************var的用法
        //    var foo=1;
        //    function bar(){
        //        if(!foo){//变量提升 foo为undefined  条件成立
        //            var foo=10;
        //        }
        //        console.log(foo)//10
        //    }
        //    bar();
        //****************let的用法
        //    let foo=1;
        //    function bar(){
        //        if(!foo){//let没有变量提升，直接赋值为1
        //            let foo=10;
        //        }
        //        console.log(foo)//1
        //    }
        //    bar();


        //***************自执行函数不带声明变量
        // let n=99;
        // (function(){
        //     let n=1;
        //     if(true){
        //         n=13;//在上一个作用域的基础上重新赋值
        //     }
        //     console.log(n);//13 找全局作用域
        // })()
        // console.log(n);//99
        //**************************
        // var n=0;
        // function a(){
        //     var n=10;
        //     function b(){
        //         n++;
        //         console.log(n);//11  第二次调用在基础上++   =>12
        //     }
        //     b();
        //     return b;
        // }
        // var c=a();
        // c();
        // console.log(n);//0
        /*
         *1.函数执行形成私有作用域：私有变量和全局变量
         *2.作用域链的查找机制：看当前函数是在哪个作用域下创建的，和在哪儿调用执行并没有关系的。
         *3.栈内存释放问题：一般执行完就会释放，但是如果里面的内容被栈以外的其他事务所占用，则就不能销毁。
         *==>掌握闭包的机制
         */

        //**********************
        //     var a=10,b=11,c=12;
        //     function text(a){
        //         a=1;
        //         var b=2;
        //         c=3;
        //     }
        //     text(10);
        //     console.log(a)//10
        //     console.log(b)//11
        //     console.log(c)//3
        //*******************************
        // "use strict"
        // var a=4;
        // function b(x,y,a){//1，2，3
        //     console.log(a);//3
        //     arguments[2]=10;//把a改为10
        //     console.log(a)//10  严格模式下是3
        // }
        // a=b(1,2,3)
        // console.log(a)//undefined  没有return返回值
        //"use strict"=>开启JS语法的严格模式(ES6或平时开发，一般基于严格模式)
        //严格JS模式下ARGUMENTS和形参的映射机制就切断了
        //**************************************************************
        //逻辑或|| 和 逻辑与&& 在赋值操作中的意义
        //A||B:先验A的真假，如果A为真，返回A的值；如果A为假，返回B的值
        //A&&B：先验A的真假，如果A为假，返回A的值；如果A为真，返回B的值
        //&&的优先级高于||
        // var foo='hello';
        // (function(foo){
        //     console.log(foo);//'hello'
        //     var foo=foo || 'world';
        //     console.log(foo)//'hello'
        // })(foo);
        // console.log(foo)//'hello'
        /*
        function fn(x,callback){
            typeof x==='undefined'?x=0:null;
            x=x||0;
            console.log(x)
            //callback代表回调函数(传递的是个函数):需要保证它是一个函数才能执行
            callback&&callback();
        }
        fn();
        fn(10);
        fn(10,function(){console.log(33)})*/
        
    </script>
</body>

</html>